name: Deploy to AWS EC2

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  BACKEND_DIR: backend
  CONTAINER_NAME: monity-mobile-backend
  APP_PORT: 3001

jobs:
  pre-flight-check:
    runs-on: ubuntu-latest
    steps:
      - name: Check EC2 Accessibility
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
          EC2_USER: ${{ secrets.EC2_USER }}
        run: |
          # Save SSH key
          if [[ "$EC2_SSH_KEY" != -----* ]]; then
            echo "$EC2_SSH_KEY" | base64 -d > ec2_key.pem
          else
            printf '%s\n' "$EC2_SSH_KEY" > ec2_key.pem
          fi
          chmod 600 ec2_key.pem

          # Test SSH port
          echo "Testing SSH port 22..."
          if nc -zv $EC2_HOST 22 -w 5 2>&1; then
            echo "âœ… SSH port 22 is accessible"
          else
            echo "âŒ SSH port 22 is not accessible"
            echo "Please check EC2 security group settings"
            exit 1
          fi

          # Test SSH authentication
          echo ""
          echo "Testing SSH authentication..."
          if ssh -i ec2_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 $EC2_USER@$EC2_HOST "echo 'âœ… SSH authentication successful'"; then
            echo "âœ… Pre-flight check passed!"
          else
            echo "âŒ SSH authentication failed"
            echo "Please verify public key is in ~/.ssh/authorized_keys on EC2"
            exit 1
          fi

          rm -f ec2_key.pem

  build-and-deploy:
    runs-on: ubuntu-latest
    needs: pre-flight-check

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create tarball of backend code
        run: |
          cd $BACKEND_DIR
          tar -czf ../monity-backend.tar.gz \
            --exclude='node_modules' \
            --exclude='dist' \
            --exclude='.git' \
            --exclude='*.log' \
            .
          cd ..
          echo "âœ… Backend tarball created"

      - name: Deploy to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
        run: |
          # Save SSH key to file with proper formatting
          # Check if key is base64 encoded (doesn't start with -----)
          if [[ "$EC2_SSH_KEY" != -----* ]]; then
            echo "Decoding base64 SSH key..."
            echo "$EC2_SSH_KEY" | base64 -d > ec2_key.pem
          else
            # Use printf to preserve line breaks
            printf '%s\n' "$EC2_SSH_KEY" > ec2_key.pem
          fi
          chmod 600 ec2_key.pem
          
          # Verify key format
          if ! grep -q "BEGIN.*PRIVATE KEY" ec2_key.pem; then
            echo "âŒ SSH key format is invalid. Make sure the secret contains the full PEM file."
            exit 1
          fi

          # Display key fingerprints for verification
          echo "ðŸ”‘ Private key fingerprint:"
          ssh-keygen -lf ec2_key.pem || echo "Could not generate fingerprint"

          echo ""
          echo "ðŸ”‘ Public key fingerprint (should match EC2 authorized_keys):"
          ssh-keygen -y -f ec2_key.pem | ssh-keygen -lf - || echo "Could not extract public key"

          # Test SSH connection with enhanced diagnostics
          echo ""
          echo "ðŸ”Œ Testing SSH connection to $EC2_USER@$EC2_HOST..."
          if ssh -vvv -i ec2_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
              $EC2_USER@$EC2_HOST "echo 'âœ… SSH connection successful'" 2>&1 | tee ssh_debug.log; then
            echo "âœ… SSH connection established"
          else
            echo "âŒ SSH connection failed. Detailed diagnostics:"
            echo ""
            echo "MOST COMMON ISSUE: Public key not in ~/.ssh/authorized_keys on EC2"
            echo ""
            echo "To extract public key from your private key locally:"
            echo "  ssh-keygen -y -f your-private-key.pem"
            echo ""
            echo "Then on EC2 instance (use EC2 Instance Connect), verify it matches:"
            echo "  cat ~/.ssh/authorized_keys"
            echo ""
            echo "Other checks:"
            echo "  1. EC2_HOST: $EC2_HOST"
            echo "  2. EC2_USER: $EC2_USER"
            echo "  3. EC2 instance is running (not stopped/terminated)"
            echo "  4. Security group allows SSH (port 22) from GitHub Actions IPs"
            echo "  5. EC2_SSH_KEY secret contains the complete private key"
            echo ""
            echo "SSH Debug Output (last 50 lines):"
            tail -50 ssh_debug.log
            exit 1
          fi

          # Copy tarball to EC2
          echo "ðŸ“¦ Copying backend code to EC2..."
          scp -i ec2_key.pem -o StrictHostKeyChecking=no monity-backend.tar.gz $EC2_USER@$EC2_HOST:/tmp/

          # Create environment file
          cat > monity.env << EOF
          NODE_ENV=${{ secrets.NODE_ENV }}
          PORT=${{ secrets.PORT }}
          HOST=${{ secrets.HOST }}
          SUPABASE_URL=${{ secrets.SUPABASE_URL }}
          SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}
          SUPABASE_KEY=${{ secrets.SUPABASE_KEY }}
          ENCRYPTION_KEY=${{ secrets.ENCRYPTION_KEY }}
          HASH_SALT=${{ secrets.HASH_SALT }}
          CLIENT_URL=${{ secrets.CLIENT_URL }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}
          STRIPE_WEBHOOK_SECRET=${{ secrets.STRIPE_WEBHOOK_SECRET }}
          STRIPE_PRICE_PREMIUM_MONTHLY=${{ secrets.STRIPE_PRICE_PREMIUM_MONTHLY }}
          GOOGLE_PLAY_PACKAGE_NAME=${{ secrets.GOOGLE_PLAY_PACKAGE_NAME }}
          GOOGLE_PLAY_SERVICE_ACCOUNT_JSON=${{ secrets.GOOGLE_PLAY_SERVICE_ACCOUNT_JSON }}
          APP_STORE_BUNDLE_ID=${{ secrets.APP_STORE_BUNDLE_ID }}
          APP_STORE_SHARED_SECRET=${{ secrets.APP_STORE_SHARED_SECRET }}
          EOF

          # Copy environment file to EC2
          echo "ðŸ“ Copying environment variables to EC2..."
          scp -i ec2_key.pem -o StrictHostKeyChecking=no monity.env $EC2_USER@$EC2_HOST:/tmp/

          # Create deployment script
          cat > deploy_remote.sh << 'DEPLOY_SCRIPT'
          #!/bin/bash
          set -e

          CONTAINER_NAME="monity-mobile-backend"
          APP_PORT=3001
          BUILD_DIR="/tmp/monity-backend-build"
          APP_DIR="/opt/monity"

          echo "=========================================="
          echo "ðŸš€ DEPLOYING MONITY BACKEND ON EC2"
          echo "=========================================="

          # Create build directory
          echo "â†’ Creating build directory..."
          rm -rf $BUILD_DIR
          mkdir -p $BUILD_DIR
          cd $BUILD_DIR

          # Extract tarball
          echo "â†’ Extracting backend code..."
          tar -xzf /tmp/monity-backend.tar.gz

          # Stop and remove old container
          echo "â†’ Stopping old container..."
          docker stop $CONTAINER_NAME 2>/dev/null || true
          docker rm $CONTAINER_NAME 2>/dev/null || true

          # Remove old images
          echo "â†’ Cleaning up old images..."
          docker images | grep monity-backend | awk '{print $3}' | xargs -r docker rmi -f 2>/dev/null || true

          # Build Docker image
          echo "â†’ Building Docker image..."
          docker build -t monity-backend:latest .

          # Create app directory
          echo "â†’ Creating app directory..."
          sudo mkdir -p $APP_DIR
          sudo chown -R $USER:$USER $APP_DIR
          cp /tmp/monity.env $APP_DIR/.env
          chmod 644 $APP_DIR/.env

          # Run container
          echo "â†’ Starting container..."
          docker run -d \
            --name $CONTAINER_NAME \
            --restart unless-stopped \
            -p $APP_PORT:$APP_PORT \
            --env-file $APP_DIR/.env \
            monity-backend:latest

          # Wait for container to start
          echo "â†’ Waiting for container to start..."
          sleep 10

          # Check container status
          if docker ps | grep -q $CONTAINER_NAME; then
              echo "âœ… Container is running!"
              docker ps --filter "name=$CONTAINER_NAME"
              echo ""
              echo "â†’ Container logs (last 30 lines):"
              docker logs $CONTAINER_NAME --tail 30
          else
              echo "âŒ Container failed to start!"
              echo "â†’ Container logs:"
              docker logs $CONTAINER_NAME --tail 100
              exit 1
          fi

          # Test local connectivity
          echo ""
          echo "â†’ Testing local connectivity..."
          sleep 5
          if curl -f http://localhost:$APP_PORT/api/v1/ > /dev/null 2>&1; then
              echo "âœ… API is responding locally!"
          else
              echo "âš  API not responding yet (may need more time to start)"
          fi

          # Cleanup
          echo "â†’ Cleaning up build files..."
          rm -rf $BUILD_DIR
          rm -f /tmp/monity-backend.tar.gz
          rm -f /tmp/monity.env

          echo ""
          echo "=========================================="
          echo "âœ… DEPLOYMENT COMPLETE!"
          echo "=========================================="
          DEPLOY_SCRIPT

          # Copy deployment script to EC2
          echo "ðŸ“‹ Copying deployment script to EC2..."
          scp -i ec2_key.pem -o StrictHostKeyChecking=no deploy_remote.sh $EC2_USER@$EC2_HOST:/tmp/

          # Execute deployment on EC2
          echo "ðŸš€ Executing deployment on EC2..."
          ssh -i ec2_key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "bash /tmp/deploy_remote.sh"

          # Cleanup local files
          rm -f ec2_key.pem monity.env deploy_remote.sh monity-backend.tar.gz

      - name: Health Check
        env:
          API_URL: ${{ secrets.API_URL }}
        run: |
          echo "ðŸ¥ Performing health check..."
          sleep 15

          # Try health check up to 5 times
          for i in {1..5}; do
            if curl -f "$API_URL/api/v1/" > /dev/null 2>&1; then
              echo "âœ… Health check passed!"
              curl "$API_URL/api/v1/"
              exit 0
            fi
            echo "â³ Health check attempt $i failed, retrying in 10s..."
            sleep 10
          done

          echo "âŒ Health check failed after 5 attempts"
          echo "âš ï¸  The deployment may still be starting up. Check EC2 logs."
          exit 1

      - name: Deployment Summary
        if: always()
        run: |
          echo "### ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Branch** | \`${{ github.ref_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Author** | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ${{ job.status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **API URL** | ${{ secrets.API_URL }}/api/v1/ |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… **Deployment successful!**" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Deployment failed. Check logs above.**" >> $GITHUB_STEP_SUMMARY
          fi
